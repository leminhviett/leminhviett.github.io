[{"content":"When dealing with conccurency problem, it is harder to reason about when moving down the stack of abstraction (machine, process, thread, hardware components, etc). Most programming languages use thread as its highest level of abstraction. Fortunately, Go build on top of that \u0026amp; introduce Goroutine.\n ‚ÄúShare memory by communicating, don‚Äôt communicate by sharing memory.‚Äù - One of Go\u0026rsquo;s mottos\n Although Golang provides traditional locking mechanism in sync package, its philosophy prefers ‚Äúshare memory by communicating‚Äù. Therefore, Golang introduces channel as the medium for Goroutines to communicate with each other.\n//goroutine go func() { // do some work }() //channel dataStream := make(chan interface{}) Fork-join model Fork-join concurrency model that Go follows\nThis concurrency model is used in Golang. At anytime; a child Goroutine can be fork to do concurrent work with its parent \u0026amp; then will join back **at some point.\nEvery Go program has a main Goroutine. The main one can be exit earlier than its children; as a result, a join point is needed to make sure children Goroutine has chance to finish.\nChannel Channel holds the following properties:\n Goroutine-safe (Multiple Goroutines can access to shared channel without race condition) FIFO queue semantics  Channel always return 2 value: 1 is object returned, 1 is status (true means valid object, false means no more values will be sent in this channel)\nintStream := make(chan int) close(intStream) integer, ok := \u0026lt;- intStream fmt.Printf(\u0026#34;(%v): %v\u0026#34;, ok, integer) // (false): 0 Channel direction var dataStream \u0026lt;-chan interface{} //read from only channel var dataStream chan\u0026lt;- interface{} // write to only channel var dataStream chan interface{} // 2 ways Channel capacity Default capacity of a channel is 0 (unbuffered channel). Reading from empty or writing to full channel is blocking.\nc := make(chan int,10) //buffered size of 10 c := make(chan int) //unbuffered channel  if a buffered channel is empty and has a receiver, the buffer will be bypassed and the value will be passed directly from the sender to the receiver.\n Channel behavior against Goroutine When a Goroutine read from or write to a channel, various of behaviours might happen depending on channel state.\nintStream := make(chan int) // 0 capacity channel  go func() { defer close(intStream) for i:=1; i\u0026lt;=5; i++{ intStream \u0026lt;- i } }() //range from a channel for integer := range intStream { // always blocked until the channel is closed \tfmt.Printf(\u0026#34;%v \u0026#34;, integer) } Below table summarizes all the behaviour:\n   Operations Channel state Result     Read nil Block    Open \u0026amp; not empty Value    Open \u0026amp; empyt Block    Closed [default value], false    Write only Compile error   Write nil Block    Open \u0026amp; full Block    Open \u0026amp; not full Write value    Closed panic    Receive only Compile error   close nil panic    Open \u0026amp; not empty Closes channel. Subsequent reads succeed value until channel is empty, then it reads deafult value.    Open \u0026amp; empty Closes channel. Reads produces default value.    Closed panic    Receive only Compile Error    As the behaviour is clomplex, we should have a way to make a robust and scalable program.\nRobust \u0026amp; scalable way when working with channel Here is 1 suggestion way:\n At most 1 Goroutine have the ownership of a channel. The channel ownership should be small to be managable. Channel owner have a write-access (chan‚Üê); While consumer only have read-only view (‚Üêchan).    Channel owners\nResponsibilities:\n Init channel Do write to channel or pass ownership to another goroutine Close channel Encapsulate \u0026amp; expose channel as a reader channel    Channel consumer\nResponsibilites:\n Handle when channel is closed Handle blocking behaviour when reading from channel    chanOwner := func() \u0026lt;-chan int { resultStream := make(chan int, 5) //init \tgo func() { defer close(resultStream) // close \tfor i:=0;i\u0026lt;=5;i++{ resultStream \u0026lt;- i // write \t} }() return resultStream // read channel returned } resultStream := chanOwner() for result := range resultStream { fmt.Printf(\u0026#34;Received: %d\\n\u0026#34;, result) } fmt.Println(\u0026#34;Done receiving!\u0026#34;) Refereneces:\nConcurrency in Go: Tools and Techniques for Developers - Book by Katherine Cox-Buday\n","permalink":"https://vietmle.com/posts/go_conc_intro/","summary":"Getting started with concept of channel \u0026amp; goroutine in Golang","title":"Intro to Concurrency in Golang"},{"content":"What is CORS?  CORS stands for Cross-Origin Resource Sharing. CORS is HTTP-header based mechanism set by server to inform client side about allowed origins (\u0026lt;scheme\u0026gt;://\u0026lt;hostname\u0026gt;:\u0026lt;port\u0026gt;) other than its own. It also indicates method and headers which the server is willing to support (example included below). Most of client browsers enforce CORS whenever a cross-origin request is made. A request is cross-origin if it calls to outside origins, which are different from the one served the first resource.  CORS behaviour will be different between simple \u0026amp; ‚Äúpre-flighted‚Äù requests. Let‚Äôs see the detail below.\nSimple requests   Refer here for full definition of simple request. For example, a GET request with no header is a simple request.\n  A simple request is sent directly to server. Let‚Äôs see how it works in the example below:\nSource: MDN web docs\n Request 1: Client browser first load a web document from domain-a.com . The main request defines its origin as domain-a.com. This origin is then specified in the request header of subsequent requests. Origin: \u0026lt;origin\u0026gt;  Request 2: Client browser then send request to GET resource from domain-a.com. As comming from the same origin, the requested resource is fetched \u0026amp; rendered by browser. Request 3: similar to request 2, but the request now is sent to domain-b.com , which is a different origin.  The resource will be successfully fetched, but \u0026hellip; It might be rendered by the browser only if in the response header, the allowed origin == domain-a.com (the request origin) or when it is a wildcard (*) meaning permit all origin.  Access-Control-Allow-Origin: \u0026lt;origin\u0026gt; | *     ‚ÄúPre-flighted‚Äù requests   Any requests that are not simple is ‚Äúpre-flighted‚Äù one.\n  Unlike simple request, the browser will send a ‚Äúpreflight‚Äù request (OPTION method) to see if the actual one (‚Äùpre-flighted‚Äù one) is allowed by the server.\nSource: MDN web docs\n  A preflight request will include the following headers:\nOrigin: \u0026lt;origin\u0026gt; Access-Control-Request-Method: \u0026lt;method\u0026gt; Access-Control-Request-Headers: \u0026lt;field-name\u0026gt;[, \u0026lt;field-name\u0026gt;]*  To inform server about method and headers used in the actual request. To ask if the server allow client origin with given headers \u0026amp; method.    Server responses with the following headers if it supports:\nAccess-Control-Allow-Origin: \u0026lt;origin\u0026gt; | * Access-Control-Allow-Methods: \u0026lt;method\u0026gt;[, \u0026lt;method\u0026gt;]* Access-Control-Allow-Headers: \u0026lt;header-name\u0026gt;[, \u0026lt;header-name\u0026gt;]* Indicating origin, method \u0026amp; headers the server supports\n  Then, the browser will compare value in the response header against corresponding info of the actual request. If all is allowed, the actual request is sent; otherwise, not.\n  The preflight request can also be cached in client side with the time-to-live indicated in Access-Control-Max-Age response header\n  Final note CORS is server-side security configurations that¬†clients may enforce it.\n Most browsers do (to avoid attack like CSRF). Some dev tools do not (like Postman).  Further reading \u0026amp; references: This article just covers surface of CORS. Further reading is highly recommended!\n Detailed visualization example: https://www.youtube.com/watch?v=Ka8vG5miErk\u0026amp;t=621s Further analysis: https://www.stackhawk.com/blog/what-is-cors/ Reference: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS  Follow me (@vietmle_) on Twitter to get update whenever my new article is out!\n","permalink":"https://vietmle.com/posts/min_cors/","summary":"CORS mechanism \u0026amp; examples","title":"The minimum every developer must know about CORS"},{"content":"Who am I? Hi there üëã . I am Viet-Minh Le (@vietmle_).\n üéì¬†Information Engineering \u0026amp; Media \u0026lsquo;22 @ NTU üíº¬†Backend Engineer @ ShopeeSG üßëüèª‚Äçüíª Tech stacks: .py, .go, .js , and some more \u0026hellip;  Why I start this blog? As a non-CS degree person, I find it overwhelmed when self-studying to become a software engineer. I was lucky enough to be guided by my senior, since then my studying process is much easier.\nAs a result, I start this blog to share my coding journey and hope some of my articles help you in some ways as well.\nMoreover, through this blog, I also hope that I can connect with and learn from new like-minded friends like you.\nFollow me (@vietmle_) on Twitter to get update whenever my new article is out!\n","permalink":"https://vietmle.com/posts/about_me/","summary":"About me \u0026amp; my blog","title":"About me"}]