[{"content":"This short article will cover comparisons between some popular concurrency primitives used when multiple threads access to shared memomory.\nThe disscussion order will go from low-level to high-level primitive, specifically: spin lock, mutex, semaphore, condition variable. The higher level is typically built on top of the lower one.\nPre-requisite This is not a beginner post you should have some background knowledge about these aforementioned stuff.\nSpin lock   Definition\nAny locking solutions require threads to do busy waiting when acquiring locks is a spin lock.\nThis can be implemented with test\u0026amp;set() - operation supported by hardware.\n  Usage\nIt is used to ensure mutual exclusion based on ownership mechanism (which means a lock can only be acquired \u0026amp; released by same thread).\n// Typical usage:  lock.acquire() // busy waiting here if lock is acquired // critical section lock.release()   Pros \u0026amp; Cons\n❌ Idle waiting wastes CPU cycle for nothing\n  Standard Mutex   Definition\nIt is aka Sleeping Lock. When acquiring this type, threads will wait by being put into sleep() in a thread_queue. Runtime system will wake-up threads when the lock is ready.\n  Usage\nLike Spin lock, with ownership mechanism, it is also used to achieve mutual exclusion.\n// Typical usage:  lock.acquire() // sleep in a queue if lock is acquired // critical section lock.release()   Pros \u0026amp; Cons\n✅ This type of lock releases CPU for other tasks. ❌ However, sleep \u0026amp; wake_up thread operation involves context switching which needs CPU usage as well.\n  Choosing between spin lock \u0026amp; mutex is an open-ended question. Yet, a rule of thumb is that if waiting time is short, spin lock is better; if waiting time is long, mutex is better\nSemaphore   Definition\nSemaphore is a variable protected by a sleeping lock. There are 2 types of semaphore: binary \u0026amp; counting.\n  Usage\nUnlike mutex \u0026amp; spin lock, semaphore uses signalling mechanism and used for synchronization purpose. Typical useacase is that one task waits to be notified by another before it starts.\n// Typical usage:  s = semaphore(counter_val, lock) // init semaphore  // counter_val --, sleep in queue if another thread currently hold lock wait(s) // do sth .... // .... // counter_val ++, sleep in queue another thread currently hold lock signal(s)   Pros \u0026amp; Cons\n❌ As lacking of ownership, any thread can call signal() \u0026amp; wait() operation. As a result, many inherent dangers are associated with using semaphore:\n Accidental signal() without wait() Deadlock … many more    Condition variable   Definition\nIt is kind of “higher-level semaphore”.\nSpecifically, it manages a queue of threads waiting for some condition states to be met. Condition states and the queue are both protected by a lock.\nMultiple condtion variables can share a same lock. But vice versa is not correct\n  Usage\nSimilar to semaphore, it also uses signalling mechanism and used for synchronization purpose.\n// Typical usage:  cv(state_var, lock) //init condition variable  lock.acquire() while (some condition related to state_var){ cv.wait() } //Do some work here.... cv.signal() // signal other threads after finishing  lock.release()   References:  Detail analysis between semaphore vs mutex: https://blog.feabhas.com/2009/09/mutex-vs-semaphores-–-part-1-semaphores/ Implementation of semaphore \u0026amp; CV: https://people.eecs.berkeley.edu/~kubitron/courses/cs162-F10/hand-outs/synch.html  ","permalink":"https://vietmle.com/posts/concurency_sync_comparison/","summary":"Quick comparison between: spin lock, mutex, semaphore, condition variable","title":"4 Concurrency Primitives Comparisons"},{"content":"This article will cover 5 simple concurrency patterns which are often used in Golang\n1. for-select pattern This is a fundamental pattern. It is typically used to read data from multiple channels.\nvar c1, c2 \u0026lt;-chan int for { // Either loop infinitely or range over something  select { case \u0026lt;-c1: // Do some work with channels  case \u0026lt;-c2: default: // auto run if other cases are not ready  } // do some work } The select statement looks like switch one, but its behavior is different. All cases are considered simultaneously \u0026amp; have equal chance to be selected. If none of the cases are ready to run, the entire select statement blocks.\n2. done channel pattern Goroutine is not garbage collected; hence, it is likely to be leaked.\ngo func() { // \u0026lt;operation that will block forever\u0026gt; // =\u0026gt; Go routine leaks }() // Do work To avoid leaking, Goroutine should be cancelled whenever it is told to do. A parent Goroutine needs to send cancellation signal to its child via a read-only channel named done . By convention, it is set as the 1st parameter.\nThis pattern is also utilized a lot in other patterns.\n//child goroutine doWork(\u0026lt;-done chan interface {}, other_params) \u0026lt;- terminated chan interface{} { terminated := make(chan interface{}) // to tell outer that it has finished  defer close(terminated) for { select: { case: //do your work here  case \u0026lt;- done: return } // do work here  } return terminated } // parent goroutine done := make(chan interface{}) terminated := doWork(done, other_args) // do sth // then tell child to stop close (done) // wait for child finish its work \u0026lt;- terminated 3. or-channel pattern This pattern aims to combine multiple done channels into one agg_done; it means that if one of a done channel is signaled, the whole agg_done channel is also closed. Yet, we do not know number of done channels during runtime in advanced.\nor-channel pattern can do so by using goroutine \u0026amp; recursion .\n// return agg_done channel var or func(channels ... \u0026lt;-chan interface{}) \u0026lt;- chan interface{} or = func(channels ...\u0026lt;-chan interface{}) \u0026lt;-chan interface{} { // base cases  switch len(channels) { case 0: return nil case 1: return channels[0] } orDone := make(chan interface{}) go func() { defer close(orDone) switch len(channels) { case 2: select { case \u0026lt;- channels[0]: case \u0026lt;- channels[1]: } default: select { case \u0026lt;- channels[0]: case \u0026lt;- channels[1]: case \u0026lt;- channels[2]: case \u0026lt;- or(append(channels[3:], orDone)...): // * line  } } } return orDone } *** line** makes the upper \u0026amp; lower recursive function depends on each other like a tree. The upper injects its own orDone channel into the lower. Then the lower also return its own orDone to the upper.\nIf any orDone channel closes, the upper \u0026amp; lower both are notified.\n4. tee channel pattern This pattern aims to split values coming from a channel into 2 others. So that we can dispatch them into two separate areas of our codebase.\ntee := func( done \u0026lt;- chan interface{}, in \u0026lt;- chan interface{}, ) (\u0026lt;- chan interface, \u0026lt;- chan interface) { out1 := make(chan interface{}) out2 := make(chan interface{}) go func() { defer close(out1) defer close(out2) //shadow outer variable  var out1, out2 = out1, out2 for val := range orDone(done, in) { for i := 0; i \u0026lt; 2; i ++ { //make sure 2 channels received same value  select { case \u0026lt;- done: case out1\u0026lt;- val: out1 = nil //stop this channel from being received  case out2\u0026lt;-val: out2 = nil } } } }() return out1, out2 } 5. bridge channel pattern Reading values from channel of channels (\u0026lt;-chan \u0026lt;-chan interface{}) can be cumbersome. Hence, this pattern aims to merge all values into 1 channel, so that the consumer jobs is much easier.\nbridge := func( done \u0026lt;- chan interface{}, chanStream \u0026lt;- \u0026lt;- interface{}, ) \u0026lt;- chan interface{} { valStream := make(chan interface{}) go func() { defer close(valStream) for { var stream \u0026lt;- chan interface{} select { case maybeStream, ok := \u0026lt;-chanStream if ok == false { return } stream = maybeStream case \u0026lt;- done: return } for val := range orDone(done, stream){ select{ case valStream \u0026lt;- val: case \u0026lt;- done: } } } }() return valStream } References:\nConcurrency in Go: Tools and Techniques for Developers - Book by Katherine Cox-Buday\n","permalink":"https://vietmle.com/posts/5_con_patterns_go/","summary":"5 simple, yet powerful, concurrency patterns in Golang","title":"5 concurrency patterns in Golang"},{"content":"When dealing with conccurency problem, it is harder to reason about when moving down the stack of abstraction (machine, process, thread, hardware components, etc). Most programming languages use thread as its highest level of abstraction. Fortunately, Go build on top of that \u0026amp; introduce Goroutine.\n “Share memory by communicating, don’t communicate by sharing memory.” - One of Go\u0026rsquo;s mottos\n Although Golang provides traditional locking mechanism in sync package, its philosophy prefers “share memory by communicating”. Therefore, Golang introduces channel as the medium for Goroutines to communicate with each other.\n//goroutine go func() { // do some work }() //channel dataStream := make(chan interface{}) Fork-join model Fork-join concurrency model that Go follows\nThis concurrency model is used in Golang. At anytime; a child Goroutine can be fork to do concurrent work with its parent \u0026amp; then will join back **at some point.\nEvery Go program has a main Goroutine. The main one can be exit earlier than its children; as a result, a join point is needed to make sure children Goroutine has chance to finish.\nChannel Channel holds the following properties:\n Goroutine-safe (Multiple Goroutines can access to shared channel without race condition) FIFO queue semantics  Channel always return 2 value: 1 is object returned, 1 is status (true means valid object, false means no more values will be sent in this channel)\nintStream := make(chan int) close(intStream) integer, ok := \u0026lt;- intStream fmt.Printf(\u0026#34;(%v): %v\u0026#34;, ok, integer) // (false): 0 Channel direction var dataStream \u0026lt;-chan interface{} //read from only channel var dataStream chan\u0026lt;- interface{} // write to only channel var dataStream chan interface{} // 2 ways Channel capacity Default capacity of a channel is 0 (unbuffered channel). Reading from empty or writing to full channel is blocking.\nc := make(chan int,10) //buffered size of 10 c := make(chan int) //unbuffered channel  if a buffered channel is empty and has a receiver, the buffer will be bypassed and the value will be passed directly from the sender to the receiver.\n Channel behavior against Goroutine When a Goroutine read from or write to a channel, various of behaviours might happen depending on channel state.\nintStream := make(chan int) // 0 capacity channel  go func() { defer close(intStream) for i:=1; i\u0026lt;=5; i++{ intStream \u0026lt;- i } }() //range from a channel for integer := range intStream { // always blocked until the channel is closed \tfmt.Printf(\u0026#34;%v \u0026#34;, integer) } Below table summarizes all the behaviour:\n   Operations Channel state Result     Read nil Block    Open \u0026amp; not empty Value    Open \u0026amp; empyt Block    Closed [default value], false    Write only Compile error   Write nil Block    Open \u0026amp; full Block    Open \u0026amp; not full Write value    Closed panic    Receive only Compile error   close nil panic    Open \u0026amp; not empty Closes channel. Subsequent reads succeed value until channel is empty, then it reads deafult value.    Open \u0026amp; empty Closes channel. Reads produces default value.    Closed panic    Receive only Compile Error    As the behaviour is clomplex, we should have a way to make a robust and scalable program.\nRobust \u0026amp; scalable way when working with channel Here is 1 suggestion way:\n At most 1 Goroutine have the ownership of a channel. The channel ownership should be small to be managable. Channel owner have a write-access (chan←); While consumer only have read-only view (←chan).    Channel owners\nResponsibilities:\n Init channel Do write to channel or pass ownership to another goroutine Close channel Encapsulate \u0026amp; expose channel as a reader channel    Channel consumer\nResponsibilites:\n Handle when channel is closed Handle blocking behaviour when reading from channel    chanOwner := func() \u0026lt;-chan int { resultStream := make(chan int, 5) //init \tgo func() { defer close(resultStream) // close \tfor i:=0;i\u0026lt;=5;i++{ resultStream \u0026lt;- i // write \t} }() return resultStream // read channel returned } resultStream := chanOwner() for result := range resultStream { fmt.Printf(\u0026#34;Received: %d\\n\u0026#34;, result) } fmt.Println(\u0026#34;Done receiving!\u0026#34;) Refereneces:\nConcurrency in Go: Tools and Techniques for Developers - Book by Katherine Cox-Buday\n","permalink":"https://vietmle.com/posts/go_conc_intro/","summary":"Getting started with concept of channel \u0026amp; goroutine in Golang","title":"Intro to Concurrency in Golang"},{"content":"What is CORS?  CORS stands for Cross-Origin Resource Sharing. CORS is HTTP-header based mechanism set by server to inform client side about allowed origins (\u0026lt;scheme\u0026gt;://\u0026lt;hostname\u0026gt;:\u0026lt;port\u0026gt;) other than its own. It also indicates method and headers which the server is willing to support (example included below). Most of client browsers enforce CORS whenever a cross-origin request is made. A request is cross-origin if it calls to outside origins, which are different from the one served the first resource.  CORS behaviour will be different between simple \u0026amp; “pre-flighted” requests. Let’s see the detail below.\nSimple requests   Refer here for full definition of simple request. For example, a GET request with no header is a simple request.\n  A simple request is sent directly to server. Let’s see how it works in the example below:\nSource: MDN web docs\n Request 1: Client browser first load a web document from domain-a.com . The main request defines its origin as domain-a.com. This origin is then specified in the request header of subsequent requests. Origin: \u0026lt;origin\u0026gt;  Request 2: Client browser then send request to GET resource from domain-a.com. As comming from the same origin, the requested resource is fetched \u0026amp; rendered by browser. Request 3: similar to request 2, but the request now is sent to domain-b.com , which is a different origin.  The resource will be successfully fetched, but \u0026hellip; It might be rendered by the browser only if in the response header, the allowed origin == domain-a.com (the request origin) or when it is a wildcard (*) meaning permit all origin.  Access-Control-Allow-Origin: \u0026lt;origin\u0026gt; | *     “Pre-flighted” requests   Any requests that are not simple is “pre-flighted” one.\n  Unlike simple request, the browser will send a “preflight” request (OPTION method) to see if the actual one (”pre-flighted” one) is allowed by the server.\nSource: MDN web docs\n  A preflight request will include the following headers:\nOrigin: \u0026lt;origin\u0026gt; Access-Control-Request-Method: \u0026lt;method\u0026gt; Access-Control-Request-Headers: \u0026lt;field-name\u0026gt;[, \u0026lt;field-name\u0026gt;]*  To inform server about method and headers used in the actual request. To ask if the server allow client origin with given headers \u0026amp; method.    Server responses with the following headers if it supports:\nAccess-Control-Allow-Origin: \u0026lt;origin\u0026gt; | * Access-Control-Allow-Methods: \u0026lt;method\u0026gt;[, \u0026lt;method\u0026gt;]* Access-Control-Allow-Headers: \u0026lt;header-name\u0026gt;[, \u0026lt;header-name\u0026gt;]* Indicating origin, method \u0026amp; headers the server supports\n  Then, the browser will compare value in the response header against corresponding info of the actual request. If all is allowed, the actual request is sent; otherwise, not.\n  The preflight request can also be cached in client side with the time-to-live indicated in Access-Control-Max-Age response header\n  Final note CORS is server-side security configurations that clients may enforce it.\n Most browsers do (to avoid attack like CSRF). Some dev tools do not (like Postman).  Further reading \u0026amp; references: This article just covers surface of CORS. Further reading is highly recommended!\n Detailed visualization example: https://www.youtube.com/watch?v=Ka8vG5miErk\u0026amp;t=621s Further analysis: https://www.stackhawk.com/blog/what-is-cors/ Reference: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS  Follow me (@vietmle_) on Twitter to get update whenever my new article is out!\n","permalink":"https://vietmle.com/posts/min_cors/","summary":"CORS mechanism \u0026amp; examples","title":"The minimum every developer must know about CORS"},{"content":"Who am I? Hi there 👋 . I am Viet-Minh Le (@vietmle_).\n 🎓 Information Engineering \u0026amp; Media \u0026lsquo;22 @ NTU 💼 Backend Engineer @ ShopeeSG 🧑🏻‍💻 Tech stacks: .py, .go, .js , and some more \u0026hellip;  Why I start this blog? As a non-CS degree person, I find it overwhelmed when self-studying to become a software engineer. I was lucky enough to be guided by my senior, since then my studying process is much easier.\nAs a result, I start this blog to share my coding journey and hope some of my articles help you in some ways as well.\nMoreover, through this blog, I also hope that I can connect with and learn from new like-minded friends like you.\nFollow me (@vietmle_) on Twitter to get update whenever my new article is out!\n","permalink":"https://vietmle.com/posts/about_me/","summary":"About me \u0026amp; my blog","title":"About me"}]