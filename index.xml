<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Viet Le&#39;s Tech Blog</title>
    <link>https://vietmle.com/</link>
    <description>Recent content on Viet Le&#39;s Tech Blog</description>
    <image>
      <url>https://vietmle.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://vietmle.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 01 Jun 2022 07:45:47 +0700</lastBuildDate><atom:link href="https://vietmle.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>5 concurrency patterns in Golang</title>
      <link>https://vietmle.com/posts/5_con_patterns_go/</link>
      <pubDate>Wed, 01 Jun 2022 07:45:47 +0700</pubDate>
      
      <guid>https://vietmle.com/posts/5_con_patterns_go/</guid>
      <description>5 simple, yet powerful, concurrency patterns in Golang</description>
      <content:encoded><![CDATA[<p>This article will cover 5 simple concurrency patterns which are often used in Golang</p>
<h2 id="1-for-select-pattern">1. <code>for-select</code> pattern</h2>
<p>This is a fundamental pattern. It is typically used to read data from multiple channels.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">{</span> <span class="c1">// Either loop infinitely or range over something 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c1</span><span class="p">:</span> <span class="c1">// Do some work with channels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="p">:</span> <span class="c1">// auto run if other cases are not ready
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// do some work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>The select statement looks like switch one, but its behavior is different. All <code>cases</code> are considered simultaneously &amp; have <strong>equal chance</strong> to be selected. If none of the <code>cases</code> are ready to run, the entire <code>select</code> statement blocks.</p>
<h2 id="2-done-channel-pattern">2. <code>done</code> channel pattern</h2>
<p>Goroutine is not garbage collected; hence, it is likely to be leaked.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &lt;operation that will block forever&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">// =&gt; Go routine leaks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Do work
</span></span></span></code></pre></div><p>To avoid leaking, Goroutine should be cancelled whenever it is told to do. A parent Goroutine needs to send cancellation signal to its child via a <em>read-only</em> channel named <code>done</code> . By convention, it is set as the 1st parameter.</p>
<p>This pattern is also utilized a lot in other patterns.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//child goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">doWork</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">done</span> <span class="kd">chan</span> <span class="kd">interface</span> <span class="p">{},</span> <span class="nx">other_params</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="nx">terminated</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">terminated</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="c1">// to tell outer that it has finished
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">terminated</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span><span class="p">:</span> <span class="c1">//do your work here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// do work here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">terminated</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// parent goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="nx">terminated</span> <span class="o">:=</span> <span class="nf">doWork</span><span class="p">(</span><span class="nx">done</span><span class="p">,</span> <span class="nx">other_args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// do sth
</span></span></span><span class="line"><span class="cl"><span class="c1">// then tell child to stop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">close</span> <span class="p">(</span><span class="nx">done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// wait for child finish its work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&lt;-</span> <span class="nx">terminated</span>
</span></span></code></pre></div><h2 id="3-or-channel-pattern">3. <code>or-channel</code> pattern</h2>
<p>This pattern aims to combine multiple <code>done</code> channels into one <code>agg_done</code>; it means that if one of a <code>done</code> channel is signaled, the whole <code>agg_done</code> channel is also closed. Yet, we do not know number of <code>done</code> channels during runtime in advanced.</p>
<p><code>or-channel</code> pattern can do so by using <code>goroutine</code> &amp; <code>recursion</code> .</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// return agg_done channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">or</span> <span class="kd">func</span><span class="p">(</span><span class="nx">channels</span> <span class="o">...</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">or</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">channels</span> <span class="o">...&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// base cases
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span> <span class="nb">len</span><span class="p">(</span><span class="nx">channels</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="nx">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">orDone</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">orDone</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="nb">len</span><span class="p">(</span><span class="nx">channels</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">                <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">channels</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">channels</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">channels</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">case</span> <span class="o">&lt;-</span> <span class="nf">or</span><span class="p">(</span><span class="nb">append</span><span class="p">(</span><span class="nx">channels</span><span class="p">[</span><span class="mi">3</span><span class="p">:],</span> <span class="nx">orDone</span><span class="p">)</span><span class="o">...</span><span class="p">):</span> <span class="c1">// * line
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">orDone</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>*** line** makes the upper &amp; lower recursive function depends on each other like a tree. The upper injects its own <code>orDone</code> channel into the lower. Then the lower also return its own <code>orDone</code> to the upper.</p>
<p>If any <code>orDone</code> channel closes, the upper &amp; lower both are notified.</p>
<h2 id="4-tee-channel-pattern">4. <code>tee</code> channel pattern</h2>
<p>This pattern aims to split values coming from a channel into 2 others. So that we can dispatch them into two separate areas of our codebase.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">tee</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">in</span> <span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">(</span><span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">,</span> <span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">out1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">    <span class="nx">out2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">out1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">out2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">//shadow outer variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">var</span> <span class="nx">out1</span><span class="p">,</span> <span class="nx">out2</span> <span class="p">=</span> <span class="nx">out1</span><span class="p">,</span> <span class="nx">out2</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">orDone</span><span class="p">(</span><span class="nx">done</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span> <span class="p">{</span> <span class="c1">//make sure 2 channels received same value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="nx">out1</span><span class="o">&lt;-</span> <span class="nx">val</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">out1</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">//stop this channel from being received
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">case</span> <span class="nx">out2</span><span class="o">&lt;-</span><span class="nx">val</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="nx">out2</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">out1</span><span class="p">,</span> <span class="nx">out2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="5-bridge-channel-pattern">5. <code>bridge</code> channel pattern</h2>
<p>Reading values from channel of channels (<code>&lt;-chan &lt;-chan interface{}</code>) can be cumbersome. Hence, this pattern aims to merge all values into 1 channel, so that the consumer jobs is much easier.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">bridge</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">chanStream</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">valStream</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">valStream</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">var</span> <span class="nx">stream</span> <span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">            <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nx">maybeStream</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">chanStream</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="nx">ok</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="nx">stream</span> <span class="p">=</span> <span class="nx">maybeStream</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">orDone</span><span class="p">(</span><span class="nx">done</span><span class="p">,</span> <span class="nx">stream</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">select</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="nx">valStream</span> <span class="o">&lt;-</span> <span class="nx">val</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">done</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">valStream</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>References:</strong></p>
<p>Concurrency in Go: Tools and Techniques for Developers - Book by Katherine Cox-Buday</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Intro to Concurrency in Golang</title>
      <link>https://vietmle.com/posts/go_conc_intro/</link>
      <pubDate>Wed, 25 May 2022 07:45:47 +0700</pubDate>
      
      <guid>https://vietmle.com/posts/go_conc_intro/</guid>
      <description>Getting started with concept of channel &amp;amp; goroutine in Golang</description>
      <content:encoded><![CDATA[<p>When dealing with conccurency problem, it is harder to reason about when moving down the stack of abstraction (machine, process, thread, hardware components, etc). Most programming languages use thread as its highest level of abstraction. Fortunately, Go build on top of that &amp; introduce <strong>Goroutine</strong>.</p>
<blockquote>
<p>‚ÄúShare memory by communicating, don‚Äôt communicate by sharing memory.‚Äù - One of Go&rsquo;s mottos</p>
</blockquote>
<p>Although Golang provides traditional locking mechanism in <code>sync</code> package, its philosophy prefers ‚Äúshare memory by communicating‚Äù. Therefore, Golang introduces <strong>channel</strong> as the medium for <strong>Goroutines</strong> to communicate with each other.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">// do some work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">dataStream</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
</span></span></code></pre></div><h2 id="fork-join-model">Fork-join model</h2>
<p><img loading="lazy" src="/images/Go_con_model.png" alt="Fork-join concurrency model that Go follows"  />

<em>Fork-join concurrency model that Go follows</em></p>
<p>This concurrency model is used in Golang. At anytime; a child Goroutine can be <em>fork</em>  to do concurrent work with its parent &amp; then will <em>join</em> back **at some point.</p>
<p>Every Go program has <em>a main Goroutine</em>. The main one can be exit earlier than its children; as a result, a join point is needed to make sure children Goroutine has chance to finish.</p>
<h2 id="channel">Channel</h2>
<p>Channel holds the following properties:</p>
<ul>
<li>Goroutine-safe (Multiple Goroutines can access to shared channel without race condition)</li>
<li>FIFO queue semantics</li>
</ul>
<p>Channel always return 2 value: 1 is object returned, 1 is status (<code>true</code> means valid object, <code>false</code> means no more values will be sent in this channel)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">intStream</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">close</span><span class="p">(</span><span class="nx">intStream</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">integer</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">intStream</span> 
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;(%v): %v&#34;</span><span class="p">,</span> <span class="nx">ok</span><span class="p">,</span> <span class="nx">integer</span><span class="p">)</span> <span class="c1">// (false): 0
</span></span></span></code></pre></div><h3 id="channel-direction">Channel direction</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dataStream</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="c1">//read from only channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">dataStream</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{}</span> <span class="c1">// write to only channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">dataStream</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span> <span class="c1">// 2 ways
</span></span></span></code></pre></div><h3 id="channel-capacity">Channel capacity</h3>
<p>Default capacity of a channel is 0 (unbuffered channel). Reading from empty or writing to full channel is blocking.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="c1">//buffered size of 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">//unbuffered channel
</span></span></span></code></pre></div><blockquote>
<p>if a buffered channel is empty and has a receiver, the buffer will be bypassed and the value will <em>be passed directly from the sender to the receiver.</em></p>
</blockquote>
<h3 id="channel-behavior-against-goroutine">Channel behavior against Goroutine</h3>
<p>When a Goroutine read from or write to a channel, various of behaviours might happen depending on channel state.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">intStream</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// 0 capacity channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">intStream</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	  <span class="nx">intStream</span> <span class="o">&lt;-</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//range from a channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="nx">integer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">intStream</span> <span class="p">{</span> <span class="c1">// always blocked until the channel is closed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v &#34;</span><span class="p">,</span> <span class="nx">integer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Below table summarizes all the behaviour:</p>
<table>
<thead>
<tr>
<th>Operations</th>
<th>Channel state</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read</td>
<td>nil</td>
<td>Block</td>
</tr>
<tr>
<td></td>
<td>Open &amp; not empty</td>
<td>Value</td>
</tr>
<tr>
<td></td>
<td>Open &amp; empyt</td>
<td>Block</td>
</tr>
<tr>
<td></td>
<td>Closed</td>
<td>[default value], <code>false</code></td>
</tr>
<tr>
<td></td>
<td>Write only</td>
<td>Compile error</td>
</tr>
<tr>
<td>Write</td>
<td>nil</td>
<td>Block</td>
</tr>
<tr>
<td></td>
<td>Open &amp; full</td>
<td>Block</td>
</tr>
<tr>
<td></td>
<td>Open &amp; not full</td>
<td>Write value</td>
</tr>
<tr>
<td></td>
<td>Closed</td>
<td><code>panic</code></td>
</tr>
<tr>
<td></td>
<td>Receive only</td>
<td>Compile error</td>
</tr>
<tr>
<td>close</td>
<td>nil</td>
<td><code>panic</code></td>
</tr>
<tr>
<td></td>
<td>Open &amp; not empty</td>
<td>Closes channel. Subsequent reads succeed value until channel is empty, then it reads deafult value.</td>
</tr>
<tr>
<td></td>
<td>Open &amp; empty</td>
<td>Closes channel. Reads produces default value.</td>
</tr>
<tr>
<td></td>
<td>Closed</td>
<td><code>panic</code></td>
</tr>
<tr>
<td></td>
<td>Receive only</td>
<td>Compile Error</td>
</tr>
</tbody>
</table>
<p>As the behaviour is clomplex, we should have a way to make a robust and scalable program.</p>
<h2 id="robust--scalable-way-when-working-with-channel">Robust &amp; scalable way when working with channel</h2>
<p>Here is 1 suggestion way:</p>
<ul>
<li>At most 1 Goroutine have the ownership of a channel. The channel ownership should be small to be managable.</li>
<li>Channel owner have a write-access (<code>chan‚Üê</code>);</li>
<li>While consumer only have read-only view (<code>‚Üêchan</code>).</li>
</ul>
<ol>
<li>
<p><strong>Channel owners</strong></p>
<p>Responsibilities:</p>
<ul>
<li><strong>Init</strong> channel</li>
<li>Do <strong>write</strong> to channel or <strong>pass ownership</strong> to another goroutine</li>
<li><strong>Close</strong> channel</li>
<li>Encapsulate &amp; expose channel as a reader channel</li>
</ul>
</li>
<li>
<p><strong>Channel</strong> <strong>consumer</strong></p>
<p>Responsibilites:</p>
<ul>
<li>Handle when channel is closed</li>
<li>Handle blocking behaviour when reading from channel</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">chanOwner</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">	<span class="nx">resultStream</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">//init
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">resultStream</span><span class="p">)</span> <span class="c1">// close
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="mi">5</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span> 
</span></span><span class="line"><span class="cl">			<span class="nx">resultStream</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="c1">// write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span> <span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">resultStream</span> <span class="c1">// read channel returned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">resultStream</span> <span class="o">:=</span> <span class="nf">chanOwner</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">result</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">resultStream</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Received: %d\n&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Done receiving!&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p><strong>Refereneces:</strong></p>
<p>Concurrency in Go: Tools and Techniques for Developers - Book by Katherine Cox-Buday</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>The minimum every developer must know about CORS</title>
      <link>https://vietmle.com/posts/min_cors/</link>
      <pubDate>Wed, 18 May 2022 09:47:52 +0700</pubDate>
      
      <guid>https://vietmle.com/posts/min_cors/</guid>
      <description>CORS mechanism &amp;amp; examples</description>
      <content:encoded><![CDATA[<h2 id="what-is-cors">What is CORS?</h2>
<ul>
<li><strong>CORS</strong> stands for <strong>Cross-Origin Resource Sharing.</strong></li>
<li>CORS is <em>HTTP-header based mechanism</em> set by server to inform client side about <em>allowed origins</em> (<code>&lt;scheme&gt;://&lt;hostname&gt;:&lt;port&gt;</code>) other than its own. It also indicates method and headers which the server is willing to support (example included below).</li>
<li><strong>Most</strong> of client browsers enforce CORS whenever <em>a cross-origin request</em> is made.
A request is cross-origin if it calls to outside origins, which are different from the one served the first resource.</li>
</ul>
<p>CORS behaviour will be different between simple &amp; ‚Äúpre-flighted‚Äù requests. Let‚Äôs see the detail below.</p>
<h3 id="simple-requests">Simple requests</h3>
<ul>
<li>
<p>Refer <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests">here</a> for full definition of simple request. For example, a GET request with no header is a simple request.</p>
</li>
<li>
<p>A simple request is sent directly to server.
Let‚Äôs see how it works in the example below:</p>
<p><img loading="lazy" src="/images/[CORS]simple_request.png" alt="Source: MDN web docs"  />

<em>Source: MDN web docs</em></p>
<ul>
<li><strong>Request 1:</strong> Client browser first load a web document from <code>domain-a.com</code> . The main request defines its <code>origin</code> as <code>domain-a.com</code>. This origin is then specified in the request header of subsequent requests.
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">Origin: <span class="p">&lt;</span><span class="nt">origin</span><span class="p">&gt;</span>
</span></span></code></pre></div></li>
<li><strong>Request 2:</strong> Client browser then send request to GET resource from <code>domain-a.com</code>. As comming from the same origin, the requested resource is fetched &amp; rendered by browser.</li>
<li><strong>Request 3:</strong> similar to request 2, but the request now is sent to <code>domain-b.com</code> , which is a different origin.
<ul>
<li>The resource will be successfully fetched, but &hellip;</li>
<li>It might be rendered by the browser only if in the response header, the allowed origin == <code>domain-a.com</code> (the request origin) or when it is a wildcard (*) meaning permit all origin.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">Access-Control-Allow-Origin: <span class="p">&lt;</span><span class="nt">origin</span><span class="p">&gt;</span> | *
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="pre-flighted-requests">‚ÄúPre-flighted‚Äù requests</h3>
<ul>
<li>
<p>Any requests that are not simple is <strong>‚Äúpre-flighted‚Äù one</strong>.</p>
</li>
<li>
<p>Unlike simple request, the browser will send a <strong><em>‚Äúpreflight‚Äù request</em></strong> (OPTION method) to see if the actual one (<strong>‚Äùpre-flighted‚Äù one</strong>) is allowed by the server.</p>
<p><img loading="lazy" src="/images/[CORS]preflighted_request.png" alt="Source: MDN web docs"  />

<em>Source: MDN web docs</em></p>
</li>
<li>
<p>A <em>preflight request</em> will include the following headers:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">Origin: <span class="p">&lt;</span><span class="nt">origin</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">Access-Control-Request-Method: <span class="p">&lt;</span><span class="nt">method</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">Access-Control-Request-Headers: <span class="p">&lt;</span><span class="nt">field-name</span><span class="p">&gt;</span>[, <span class="p">&lt;</span><span class="nt">field-name</span><span class="p">&gt;</span>]*
</span></span></code></pre></div><ul>
<li>To inform server about method and headers used in the actual request.</li>
<li>To ask if the server allow client origin with given headers &amp; method.</li>
</ul>
</li>
<li>
<p>Server responses with the following headers if it supports:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">Access-Control-Allow-Origin: <span class="p">&lt;</span><span class="nt">origin</span><span class="p">&gt;</span> | *
</span></span><span class="line"><span class="cl">Access-Control-Allow-Methods: <span class="p">&lt;</span><span class="nt">method</span><span class="p">&gt;</span>[, <span class="p">&lt;</span><span class="nt">method</span><span class="p">&gt;</span>]*
</span></span><span class="line"><span class="cl">Access-Control-Allow-Headers: <span class="p">&lt;</span><span class="nt">header-name</span><span class="p">&gt;</span>[, <span class="p">&lt;</span><span class="nt">header-name</span><span class="p">&gt;</span>]*
</span></span></code></pre></div><p>Indicating origin, method &amp; headers the server supports</p>
</li>
<li>
<p>Then, the browser will compare value in the response header against corresponding info of the actual request. <strong>If all is allowed, the actual request is sent; otherwise, not.</strong></p>
</li>
<li>
<p>The preflight request can also be cached in client side with the time-to-live indicated in <code>Access-Control-Max-Age</code> response header</p>
</li>
</ul>
<h2 id="final-note">Final note</h2>
<p>CORS is server-side security configurations that¬†<strong>clients may enforce it.</strong></p>
<ul>
<li>Most browsers do (to avoid attack like CSRF).</li>
<li>Some dev tools do not (like Postman).</li>
</ul>
<h2 id="further-reading--references">Further reading &amp; references:</h2>
<p>This article just covers surface of CORS. Further reading is highly recommended!</p>
<ul>
<li>Detailed visualization example: <a href="https://www.youtube.com/watch?v=Ka8vG5miErk&amp;t=621s">https://www.youtube.com/watch?v=Ka8vG5miErk&amp;t=621s</a></li>
<li>Further analysis: <a href="https://www.stackhawk.com/blog/what-is-cors/">https://www.stackhawk.com/blog/what-is-cors/</a></li>
<li>Reference: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a></li>
</ul>
<p><em>Follow me (<a href="https://twitter.com/vietmle_">@vietmle_</a>) on Twitter to get update whenever my new article is out!</em></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://vietmle.com/posts/about_me/</link>
      <pubDate>Fri, 06 May 2022 14:52:19 +0800</pubDate>
      
      <guid>https://vietmle.com/posts/about_me/</guid>
      <description>About me &amp;amp; my blog</description>
      <content:encoded><![CDATA[<h2 id="who-am-i">Who am I?</h2>
<p>Hi there üëã . I am Viet-Minh Le (<a href="https://twitter.com/vietmle_">@vietmle_</a>).</p>
<ul>
<li>üéì¬† Information Engineering &amp; Media &lsquo;22 @ <a href="https://www.ntu.edu.sg/">NTU</a></li>
<li>üíº¬† Backend Engineer @ <a href="https://shopee.sg/">ShopeeSG</a></li>
<li>üßëüèª‚Äçüíª Tech stacks: <code>.py</code>, <code>.go</code>, <code>.js</code> , and some more &hellip;</li>
</ul>
<h2 id="why-i-start-this-blog">Why I start this blog?</h2>
<p>As a non-CS degree person, I find it overwhelmed when self-studying to become a software engineer. I was lucky enough to be guided by my senior, since then my studying process is much easier.</p>
<p>As a result, I start this blog to share my coding journey and hope some of my articles help you in some ways as well.</p>
<p>Moreover, through this blog, I also hope that I can connect with and learn from new like-minded friends like you.</p>
<p><em>Follow me (<a href="https://twitter.com/vietmle_">@vietmle_</a>) on Twitter to get update whenever my new article is out!</em></p>
]]></content:encoded>
    </item>
    
    
  </channel>
</rss>
