<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>5 concurrency patterns in Golang | Viet Le's Tech Blog</title><meta name=keywords content="Golang,concurrency"><meta name=description content="5 simple, yet powerful, concurrency patterns in Golang"><meta name=author content="Viet Le"><link rel=canonical href=https://vietmle.com/posts/5_con_patterns_go/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://vietmle.com/images/ava.png><link rel=icon type=image/png sizes=16x16 href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-FBXNST367F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FBXNST367F",{anonymize_ip:!1})}</script><meta property="og:title" content="5 concurrency patterns in Golang"><meta property="og:description" content="5 simple, yet powerful, concurrency patterns in Golang"><meta property="og:type" content="article"><meta property="og:url" content="https://vietmle.com/posts/5_con_patterns_go/"><meta property="og:image" content="https://vietmle.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-01T07:45:47+07:00"><meta property="article:modified_time" content="2022-06-01T07:45:47+07:00"><meta property="og:site_name" content="Viet Le's Tech Blog"><meta property="og:see_also" content="https://vietmle.com/posts/go_conc_intro/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vietmle.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="5 concurrency patterns in Golang"><meta name=twitter:description content="5 simple, yet powerful, concurrency patterns in Golang"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vietmle.com/posts/"},{"@type":"ListItem","position":2,"name":"5 concurrency patterns in Golang","item":"https://vietmle.com/posts/5_con_patterns_go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"5 concurrency patterns in Golang","name":"5 concurrency patterns in Golang","description":"5 simple, yet powerful, concurrency patterns in Golang","keywords":["Golang","concurrency"],"articleBody":"This article will cover 5 simple concurrency patterns which are often used in Golang\n1. for-select pattern This is a fundamental pattern. It is typically used to read data from multiple channels.\nvar c1, c2 chan int for { // Either loop infinitely or range over something  select { case c1: // Do some work with channels  case c2: default: // auto run if other cases are not ready  } // do some work } The select statement looks like switch one, but its behavior is different. All cases are considered simultaneously \u0026 have equal chance to be selected. If none of the cases are ready to run, the entire select statement blocks.\n2. done channel pattern Goroutine is not garbage collected; hence, it is likely to be leaked.\ngo func() { // // = Go routine leaks }() // Do work To avoid leaking, Goroutine should be cancelled whenever it is told to do. A parent Goroutine needs to send cancellation signal to its child via a read-only channel named done . By convention, it is set as the 1st parameter.\nThis pattern is also utilized a lot in other patterns.\n//child goroutine doWork(done chan interface {}, other_params)  terminated chan interface{} { terminated := make(chan interface{}) // to tell outer that it has finished  defer close(terminated) for { select: { case: //do your work here  case  done: return } // do work here  } return terminated } // parent goroutine done := make(chan interface{}) terminated := doWork(done, other_args) // do sth // then tell child to stop close (done) // wait for child finish its work  terminated 3. or-channel pattern This pattern aims to combine multiple done channels into one agg_done; it means that if one of a done channel is signaled, the whole agg_done channel is also closed. Yet, we do not know number of done channels during runtime in advanced.\nor-channel pattern can do so by using goroutine \u0026 recursion .\n// return agg_done channel var or func(channels ... chan interface{})  chan interface{} or = func(channels ...chan interface{}) chan interface{} { // base cases  switch len(channels) { case 0: return nil case 1: return channels[0] } orDone := make(chan interface{}) go func() { defer close(orDone) switch len(channels) { case 2: select { case  channels[0]: case  channels[1]: } default: select { case  channels[0]: case  channels[1]: case  channels[2]: case  or(append(channels[3:], orDone)...): // * line  } } } return orDone } *** line** makes the upper \u0026 lower recursive function depends on each other like a tree. The upper injects its own orDone channel into the lower. Then the lower also return its own orDone to the upper.\nIf any orDone channel closes, the upper \u0026 lower both are notified.\n4. tee channel pattern This pattern aims to split values coming from a channel into 2 others. So that we can dispatch them into two separate areas of our codebase.\ntee := func( done  chan interface{}, in  chan interface{}, ) ( chan interface,  chan interface) { out1 := make(chan interface{}) out2 := make(chan interface{}) go func() { defer close(out1) defer close(out2) //shadow outer variable  var out1, out2 = out1, out2 for val := range orDone(done, in) { for i := 0; i  2; i ++ { //make sure 2 channels received same value  select { case  done: case out1 val: out1 = nil //stop this channel from being received  case out2val: out2 = nil } } } }() return out1, out2 } 5. bridge channel pattern Reading values from channel of channels () can be cumbersome. Hence, this pattern aims to merge all values into 1 channel, so that the consumer jobs is much easier.\nbridge := func( done  chan interface{}, chanStream   interface{}, )  chan interface{} { valStream := make(chan interface{}) go func() { defer close(valStream) for { var stream  chan interface{} select { case maybeStream, ok := chanStream if ok == false { return } stream = maybeStream case  done: return } for val := range orDone(done, stream){ select{ case valStream  val: case  done: } } } }() return valStream } References:\nConcurrency in Go: Tools and Techniques for Developers - Book by Katherine Cox-Buday\n","wordCount":"716","inLanguage":"en","datePublished":"2022-06-01T07:45:47+07:00","dateModified":"2022-06-01T07:45:47+07:00","author":{"@type":"Person","name":"Viet Le"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vietmle.com/posts/5_con_patterns_go/"},"publisher":{"@type":"Organization","name":"Viet Le's Tech Blog","logo":{"@type":"ImageObject","url":"https://vietmle.com/images/ava.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vietmle.com/ accesskey=h title="Home (Alt + H)"><img src=https://vietmle.com/images/ava.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://vietmle.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://vietmle.com/series/ title=Series><span>Series</span></a></li><li><a href=https://vietmle.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://vietmle.com/posts/about_me title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vietmle.com/>Home</a>&nbsp;»&nbsp;<a href=https://vietmle.com/posts/>Posts</a></div><h1 class=post-title>5 concurrency patterns in Golang</h1><div class=post-meta><span title="2022-06-01 07:45:47 +0700 +0700">June 1, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Viet Le</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-for-select-pattern aria-label="1. for-select pattern">1. <code>for-select</code> pattern</a></li><li><a href=#2-done-channel-pattern aria-label="2. done channel pattern">2. <code>done</code> channel pattern</a></li><li><a href=#3-or-channel-pattern aria-label="3. or-channel pattern">3. <code>or-channel</code> pattern</a></li><li><a href=#4-tee-channel-pattern aria-label="4. tee channel pattern">4. <code>tee</code> channel pattern</a></li><li><a href=#5-bridge-channel-pattern aria-label="5. bridge channel pattern">5. <code>bridge</code> channel pattern</a></li></ul></div></details></div><div class=post-content><p>This article will cover 5 simple concurrency patterns which are often used in Golang</p><h2 id=1-for-select-pattern>1. <code>for-select</code> pattern<a hidden class=anchor aria-hidden=true href=#1-for-select-pattern>#</a></h2><p>This is a fundamental pattern. It is typically used to read data from multiple channels.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>c1</span><span class=p>,</span> <span class=nx>c2</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span> <span class=c1>// Either loop infinitely or range over something 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>c1</span><span class=p>:</span> <span class=c1>// Do some work with channels
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>c2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=p>:</span> <span class=c1>// auto run if other cases are not ready
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// do some work
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The select statement looks like switch one, but its behavior is different. All <code>cases</code> are considered simultaneously & have <strong>equal chance</strong> to be selected. If none of the <code>cases</code> are ready to run, the entire <code>select</code> statement blocks.</p><h2 id=2-done-channel-pattern>2. <code>done</code> channel pattern<a hidden class=anchor aria-hidden=true href=#2-done-channel-pattern>#</a></h2><p>Goroutine is not garbage collected; hence, it is likely to be leaked.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// &lt;operation that will block forever&gt;
</span></span></span><span class=line><span class=cl><span class=c1>// =&gt; Go routine leaks
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=c1>// Do work
</span></span></span></code></pre></div><p>To avoid leaking, Goroutine should be cancelled whenever it is told to do. A parent Goroutine needs to send cancellation signal to its child via a <em>read-only</em> channel named <code>done</code> . By convention, it is set as the 1st parameter.</p><p>This pattern is also utilized a lot in other patterns.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//child goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>doWork</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>done</span> <span class=kd>chan</span> <span class=kd>interface</span> <span class=p>{},</span> <span class=nx>other_params</span><span class=p>)</span> <span class=o>&lt;-</span> <span class=nx>terminated</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>terminated</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span> <span class=c1>// to tell outer that it has finished
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>terminated</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>select</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span><span class=p>:</span> <span class=c1>//do your work here
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// do work here
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>terminated</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// parent goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=nx>terminated</span> <span class=o>:=</span> <span class=nf>doWork</span><span class=p>(</span><span class=nx>done</span><span class=p>,</span> <span class=nx>other_args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// do sth
</span></span></span><span class=line><span class=cl><span class=c1>// then tell child to stop
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>close</span> <span class=p>(</span><span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// wait for child finish its work
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&lt;-</span> <span class=nx>terminated</span>
</span></span></code></pre></div><h2 id=3-or-channel-pattern>3. <code>or-channel</code> pattern<a hidden class=anchor aria-hidden=true href=#3-or-channel-pattern>#</a></h2><p>This pattern aims to combine multiple <code>done</code> channels into one <code>agg_done</code>; it means that if one of a <code>done</code> channel is signaled, the whole <code>agg_done</code> channel is also closed. Yet, we do not know number of <code>done</code> channels during runtime in advanced.</p><p><code>or-channel</code> pattern can do so by using <code>goroutine</code> & <code>recursion</code> .</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// return agg_done channel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>or</span> <span class=kd>func</span><span class=p>(</span><span class=nx>channels</span> <span class=o>...</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span> <span class=o>&lt;-</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>or</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>channels</span> <span class=o>...&lt;-</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// base cases
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>switch</span> <span class=nb>len</span><span class=p>(</span><span class=nx>channels</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>0</span><span class=p>:</span> <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>1</span><span class=p>:</span> <span class=k>return</span> <span class=nx>channels</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>orDone</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>orDone</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>switch</span> <span class=nb>len</span><span class=p>(</span><span class=nx>channels</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=mi>2</span><span class=p>:</span> 
</span></span><span class=line><span class=cl>                <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>channels</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>channels</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>channels</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>channels</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>channels</span><span class=p>[</span><span class=mi>2</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=k>case</span> <span class=o>&lt;-</span> <span class=nf>or</span><span class=p>(</span><span class=nb>append</span><span class=p>(</span><span class=nx>channels</span><span class=p>[</span><span class=mi>3</span><span class=p>:],</span> <span class=nx>orDone</span><span class=p>)</span><span class=o>...</span><span class=p>):</span> <span class=c1>// * line
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>orDone</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>*** line** makes the upper & lower recursive function depends on each other like a tree. The upper injects its own <code>orDone</code> channel into the lower. Then the lower also return its own <code>orDone</code> to the upper.</p><p>If any <code>orDone</code> channel closes, the upper & lower both are notified.</p><h2 id=4-tee-channel-pattern>4. <code>tee</code> channel pattern<a hidden class=anchor aria-hidden=true href=#4-tee-channel-pattern>#</a></h2><p>This pattern aims to split values coming from a channel into 2 others. So that we can dispatch them into two separate areas of our codebase.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>tee</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>    <span class=nx>in</span> <span class=o>&lt;-</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{},</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>(</span><span class=o>&lt;-</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>,</span> <span class=o>&lt;-</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>out1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>    <span class=nx>out2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>out1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>out2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//shadow outer variable
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>var</span> <span class=nx>out1</span><span class=p>,</span> <span class=nx>out2</span> <span class=p>=</span> <span class=nx>out1</span><span class=p>,</span> <span class=nx>out2</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=nx>val</span> <span class=o>:=</span> <span class=k>range</span> <span class=nf>orDone</span><span class=p>(</span><span class=nx>done</span><span class=p>,</span> <span class=nx>in</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>2</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span> <span class=c1>//make sure 2 channels received same value
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=nx>out1</span><span class=o>&lt;-</span> <span class=nx>val</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=nx>out1</span> <span class=p>=</span> <span class=kc>nil</span> <span class=c1>//stop this channel from being received
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>case</span> <span class=nx>out2</span><span class=o>&lt;-</span><span class=nx>val</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=nx>out2</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>out1</span><span class=p>,</span> <span class=nx>out2</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=5-bridge-channel-pattern>5. <code>bridge</code> channel pattern<a hidden class=anchor aria-hidden=true href=#5-bridge-channel-pattern>#</a></h2><p>Reading values from channel of channels (<code>&lt;-chan &lt;-chan interface{}</code>) can be cumbersome. Hence, this pattern aims to merge all values into 1 channel, so that the consumer jobs is much easier.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>bridge</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>done</span> <span class=o>&lt;-</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{},</span>
</span></span><span class=line><span class=cl>    <span class=nx>chanStream</span> <span class=o>&lt;-</span> <span class=o>&lt;-</span> <span class=kd>interface</span><span class=p>{},</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=o>&lt;-</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>valStream</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>valStream</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>var</span> <span class=nx>stream</span> <span class=o>&lt;-</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>            <span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nx>maybeStream</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>chanStream</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nx>ok</span> <span class=o>==</span> <span class=kc>false</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=nx>stream</span> <span class=p>=</span> <span class=nx>maybeStream</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=nx>val</span> <span class=o>:=</span> <span class=k>range</span> <span class=nf>orDone</span><span class=p>(</span><span class=nx>done</span><span class=p>,</span> <span class=nx>stream</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>select</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=nx>valStream</span> <span class=o>&lt;-</span> <span class=nx>val</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>valStream</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>References:</strong></p><p>Concurrency in Go: Tools and Techniques for Developers - Book by Katherine Cox-Buday</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://vietmle.com/tags/golang/>Golang</a></li><li><a href=https://vietmle.com/tags/concurrency/>concurrency</a></li></ul><nav class=paginav><a class=prev href=https://vietmle.com/posts/concurency_sync_comparison/><span class=title>« Prev Page</span><br><span>4 Concurrency Primitives Comparisons</span></a>
<a class=next href=https://vietmle.com/posts/go_conc_intro/><span class=title>Next Page »</span><br><span>Intro to Concurrency in Golang</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://vietmle.com/>Viet Le's Tech Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>