<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>4 Concurrency Primitives Comparisons | Viet Le's Tech Blog</title><meta name=keywords content="concurrency"><meta name=description content="Quick comparison between: spin lock, mutex, semaphore, condition variable"><meta name=author content="Viet Le"><link rel=canonical href=https://vietmle.com/posts/concurency_sync_comparison/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://vietmle.com/images/ava.png><link rel=icon type=image/png sizes=16x16 href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-FBXNST367F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FBXNST367F",{anonymize_ip:!1})}</script><meta property="og:title" content="4 Concurrency Primitives Comparisons"><meta property="og:description" content="Quick comparison between: spin lock, mutex, semaphore, condition variable"><meta property="og:type" content="article"><meta property="og:url" content="https://vietmle.com/posts/concurency_sync_comparison/"><meta property="og:image" content="https://vietmle.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-08T07:45:47+07:00"><meta property="article:modified_time" content="2022-06-08T07:45:47+07:00"><meta property="og:site_name" content="Viet Le's Tech Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vietmle.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="4 Concurrency Primitives Comparisons"><meta name=twitter:description content="Quick comparison between: spin lock, mutex, semaphore, condition variable"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vietmle.com/posts/"},{"@type":"ListItem","position":2,"name":"4 Concurrency Primitives Comparisons","item":"https://vietmle.com/posts/concurency_sync_comparison/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"4 Concurrency Primitives Comparisons","name":"4 Concurrency Primitives Comparisons","description":"Quick comparison between: spin lock, mutex, semaphore, condition variable","keywords":["concurrency"],"articleBody":"This short article will cover comparisons between some popular concurrency primitives used when multiple threads access to shared memomory.\nThe disscussion order will go from low-level to high-level primitive, specifically: spin lock, mutex, semaphore, condition variable. The higher level is typically built on top of the lower one.\nPre-requisite This is not a beginner post you should have some background knowledge about these aforementioned stuff.\nSpin lock   Definition\nAny locking solutions require threads to do busy waiting when acquiring locks is a spin lock.\nThis can be implemented with test\u0026set() - operation supported by hardware.\n  Usage\nIt is used to ensure mutual exclusion based on ownership mechanism (which means a lock can only be acquired \u0026 released by same thread).\n// Typical usage:  lock.acquire() // busy waiting here if lock is acquired // critical section lock.release()   Pros \u0026 Cons\n❌ Idle waiting wastes CPU cycle for nothing\n  Standard Mutex   Definition\nIt is aka Sleeping Lock. When acquiring this type, threads will wait by being put into sleep() in a thread_queue. Runtime system will wake-up threads when the lock is ready.\n  Usage\nLike Spin lock, with ownership mechanism, it is also used to achieve mutual exclusion.\n// Typical usage:  lock.acquire() // sleep in a queue if lock is acquired // critical section lock.release()   Pros \u0026 Cons\n✅ This type of lock releases CPU for other tasks. ❌ However, sleep \u0026 wake_up thread operation involves context switching which needs CPU usage as well.\n  Choosing between spin lock \u0026 mutex is an open-ended question. Yet, a rule of thumb is that if waiting time is short, spin lock is better; if waiting time is long, mutex is better\nSemaphore   Definition\nSemaphore is a variable protected by a sleeping lock. There are 2 types of semaphore: binary \u0026 counting.\n  Usage\nUnlike mutex \u0026 spin lock, semaphore uses signalling mechanism and used for synchronization purpose. Typical useacase is that one task waits to be notified by another before it starts.\n// Typical usage:  s = semaphore(counter_val, lock) // init semaphore  // counter_val --, sleep in queue if another thread currently hold lock wait(s) // do sth .... // .... // counter_val ++, sleep in queue another thread currently hold lock signal(s)   Pros \u0026 Cons\n❌ As lacking of ownership, any thread can call signal() \u0026 wait() operation. As a result, many inherent dangers are associated with using semaphore:\n Accidental signal() without wait() Deadlock … many more    Condition variable   Definition\nIt is kind of “higher-level semaphore”.\nSpecifically, it manages a queue of threads waiting for some condition states to be met. Condition states and the queue are both protected by a lock.\nMultiple condtion variables can share a same lock. But vice versa is not correct\n  Usage\nSimilar to semaphore, it also uses signalling mechanism and used for synchronization purpose.\n// Typical usage:  cv(state_var, lock) //init condition variable  lock.acquire() while (some condition related to state_var){ cv.wait() } //Do some work here.... cv.signal() // signal other threads after finishing  lock.release()   References:  Detail analysis between semaphore vs mutex: https://blog.feabhas.com/2009/09/mutex-vs-semaphores-–-part-1-semaphores/ Implementation of semaphore \u0026 CV: https://people.eecs.berkeley.edu/~kubitron/courses/cs162-F10/hand-outs/synch.html  ","wordCount":"507","inLanguage":"en","datePublished":"2022-06-08T07:45:47+07:00","dateModified":"2022-06-08T07:45:47+07:00","author":{"@type":"Person","name":"Viet Le"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vietmle.com/posts/concurency_sync_comparison/"},"publisher":{"@type":"Organization","name":"Viet Le's Tech Blog","logo":{"@type":"ImageObject","url":"https://vietmle.com/images/ava.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vietmle.com/ accesskey=h title="Home (Alt + H)"><img src=https://vietmle.com/images/ava.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://vietmle.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://vietmle.com/series/ title=Series><span>Series</span></a></li><li><a href=https://vietmle.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://vietmle.com/posts/about_me title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vietmle.com/>Home</a>&nbsp;»&nbsp;<a href=https://vietmle.com/posts/>Posts</a></div><h1 class=post-title>4 Concurrency Primitives Comparisons</h1><div class=post-meta><span title="2022-06-08 07:45:47 +0700 +0700">June 8, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Viet Le</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#pre-requisite aria-label=Pre-requisite>Pre-requisite</a></li><li><a href=#spin-lock aria-label="Spin lock">Spin lock</a></li><li><a href=#standard-mutex aria-label="Standard Mutex">Standard Mutex</a></li><li><a href=#semaphore aria-label=Semaphore>Semaphore</a></li><li><a href=#condition-variable aria-label="Condition variable">Condition variable</a></li><li><a href=#references aria-label=References:>References:</a></li></ul></div></details></div><div class=post-content><p>This short article will cover comparisons between some popular concurrency primitives used when multiple threads access to shared memomory.</p><p>The disscussion order will go from low-level to high-level primitive, specifically: spin lock, mutex, semaphore, condition variable. The higher level is typically built on top of the lower one.</p><h2 id=pre-requisite>Pre-requisite<a hidden class=anchor aria-hidden=true href=#pre-requisite>#</a></h2><p>This is not a beginner post you should have some background knowledge about these aforementioned stuff.</p><h2 id=spin-lock>Spin lock<a hidden class=anchor aria-hidden=true href=#spin-lock>#</a></h2><ul><li><p><strong>Definition</strong></p><p>Any locking solutions require threads to do busy waiting when acquiring locks is a spin lock.</p><p>This can be implemented with <code>test&set()</code> - operation supported by hardware.</p></li><li><p><strong>Usage</strong></p><p>It is used to ensure mutual exclusion based on <em><strong>ownership mechanism</strong></em> (which means a lock can only be acquired & released by same thread).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Typical usage:
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>lock</span><span class=p>.</span><span class=n>acquire</span><span class=p>()</span> <span class=c1>// busy waiting here if lock is acquired
</span></span></span><span class=line><span class=cl><span class=c1>// critical section
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>lock</span><span class=p>.</span><span class=n>release</span><span class=p>()</span>
</span></span></code></pre></div></li><li><p><strong>Pros & Cons</strong></p><p>❌ Idle waiting wastes CPU cycle for nothing</p></li></ul><h2 id=standard-mutex>Standard Mutex<a hidden class=anchor aria-hidden=true href=#standard-mutex>#</a></h2><ul><li><p><strong>Definition</strong></p><p>It is aka Sleeping Lock. When acquiring this type, threads will wait by being put into <code>sleep()</code> in a <code>thread_queue</code>. Runtime system will wake-up threads when the lock is ready.</p></li><li><p><strong>Usage</strong></p><p>Like Spin lock, with ownership mechanism, it is also used to achieve mutual exclusion.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Typical usage:
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>lock</span><span class=p>.</span><span class=n>acquire</span><span class=p>()</span> <span class=c1>// sleep in a queue if lock is acquired
</span></span></span><span class=line><span class=cl><span class=c1>// critical section
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>lock</span><span class=p>.</span><span class=n>release</span><span class=p>()</span>
</span></span></code></pre></div></li><li><p><strong>Pros & Cons</strong></p><p>✅ This type of lock releases CPU for other tasks.
❌ However, <code>sleep</code> & <code>wake_up</code> thread operation involves context switching which needs CPU usage as well.</p></li></ul><p>Choosing between spin lock & mutex is an open-ended question. Yet, a rule of thumb is that if waiting time is short, spin lock is better; if waiting time is long, mutex is better</p><h2 id=semaphore>Semaphore<a hidden class=anchor aria-hidden=true href=#semaphore>#</a></h2><ul><li><p><strong>Definition</strong></p><p>Semaphore is a variable protected by a sleeping lock. There are 2 types of semaphore: binary & counting.</p></li><li><p><strong>Usage</strong></p><p>Unlike mutex & spin lock, semaphore uses <em><strong>signalling mechanism</strong></em> and used for synchronization purpose. Typical useacase is that one task waits to be notified by another before it starts.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Typical usage:
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>semaphore</span><span class=p>(</span><span class=n>counter_val</span><span class=p>,</span> <span class=n>lock</span><span class=p>)</span> <span class=c1>// init semaphore
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// counter_val --, sleep in queue if another thread currently hold lock
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>wait</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// do sth ....
</span></span></span><span class=line><span class=cl><span class=c1>// ....
</span></span></span><span class=line><span class=cl><span class=c1>// counter_val ++, sleep in queue another thread currently hold lock
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>signal</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> 
</span></span></code></pre></div></li><li><p><strong>Pros & Cons</strong></p><p>❌  As lacking of ownership, any thread can call <code>signal()</code> & <code>wait()</code> operation. As a result, many inherent dangers are associated with using semaphore:</p><ul><li>Accidental <code>signal()</code> without <code>wait()</code></li><li>Deadlock</li><li>… many more</li></ul></li></ul><h2 id=condition-variable>Condition variable<a hidden class=anchor aria-hidden=true href=#condition-variable>#</a></h2><ul><li><p><strong>Definition</strong></p><p>It is kind of “higher-level semaphore”.</p><p>Specifically, it manages a queue of threads waiting for some condition states to be met. Condition states and the queue are both protected by a lock.</p><p>Multiple condtion variables can share a same lock. But vice versa is not correct</p></li><li><p><strong>Usage</strong></p><p>Similar to semaphore, it also uses <em><strong>signalling mechanism</strong></em> and used for synchronization purpose.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Typical usage:
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=p>(</span><span class=n>state_var</span><span class=p>,</span> <span class=n>lock</span><span class=p>)</span> <span class=c1>//init condition variable
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>lock</span><span class=p>.</span><span class=n>acquire</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>some</span> <span class=n>condition</span> <span class=n>related</span> <span class=n>to</span> <span class=n>state_var</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>cv</span><span class=p>.</span><span class=n>wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//Do some work here....
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cv</span><span class=p>.</span><span class=n>signal</span><span class=p>()</span> <span class=c1>// signal other threads after finishing
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>lock</span><span class=p>.</span><span class=n>release</span><span class=p>()</span>
</span></span></code></pre></div></li></ul><h2 id=references>References:<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>Detail analysis between semaphore vs mutex: <a href=https://blog.feabhas.com/2009/09/mutex-vs-semaphores-%e2%80%93-part-1-semaphores/>https://blog.feabhas.com/2009/09/mutex-vs-semaphores-–-part-1-semaphores/</a></li><li>Implementation of semaphore & CV: <a href=https://people.eecs.berkeley.edu/~kubitron/courses/cs162-F10/hand-outs/synch.html>https://people.eecs.berkeley.edu/~kubitron/courses/cs162-F10/hand-outs/synch.html</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://vietmle.com/tags/concurrency/>concurrency</a></li></ul><nav class=paginav><a class=next href=https://vietmle.com/posts/5_con_patterns_go/><span class=title>Next Page »</span><br><span>5 concurrency patterns in Golang</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vietmle.com/>Viet Le's Tech Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>