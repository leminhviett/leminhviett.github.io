<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Intro to Concurrency in Golang | Viet Le's Tech Blog</title><meta name=keywords content="Golang,concurrency"><meta name=description content="Getting started with concept of channel & goroutine in Golang"><meta name=author content="Viet Le"><link rel=canonical href=https://vietmle.com/posts/go_conc_intro/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://vietmle.com/images/ava.png><link rel=icon type=image/png sizes=16x16 href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vietmle.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-FBXNST367F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FBXNST367F",{anonymize_ip:!1})}</script><meta property="og:title" content="Intro to Concurrency in Golang"><meta property="og:description" content="Getting started with concept of channel & goroutine in Golang"><meta property="og:type" content="article"><meta property="og:url" content="https://vietmle.com/posts/go_conc_intro/"><meta property="og:image" content="https://vietmle.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-25T07:45:47+07:00"><meta property="article:modified_time" content="2022-05-25T07:45:47+07:00"><meta property="og:site_name" content="Viet Le's Tech Blog"><meta property="og:see_also" content="https://vietmle.com/posts/5_con_patterns_go/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://vietmle.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Intro to Concurrency in Golang"><meta name=twitter:description content="Getting started with concept of channel & goroutine in Golang"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vietmle.com/posts/"},{"@type":"ListItem","position":2,"name":"Intro to Concurrency in Golang","item":"https://vietmle.com/posts/go_conc_intro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Intro to Concurrency in Golang","name":"Intro to Concurrency in Golang","description":"Getting started with concept of channel \u0026amp; goroutine in Golang","keywords":["Golang","concurrency"],"articleBody":"When dealing with conccurency problem, it is harder to reason about when moving down the stack of abstraction (machine, process, thread, hardware components, etc). Most programming languages use thread as its highest level of abstraction. Fortunately, Go build on top of that \u0026 introduce Goroutine.\n “Share memory by communicating, don’t communicate by sharing memory.” - One of Go’s mottos\n Although Golang provides traditional locking mechanism in sync package, its philosophy prefers “share memory by communicating”. Therefore, Golang introduces channel as the medium for Goroutines to communicate with each other.\n//goroutine go func() { // do some work }() //channel dataStream := make(chan interface{}) Fork-join model Fork-join concurrency model that Go follows\nThis concurrency model is used in Golang. At anytime; a child Goroutine can be fork to do concurrent work with its parent \u0026 then will join back **at some point.\nEvery Go program has a main Goroutine. The main one can be exit earlier than its children; as a result, a join point is needed to make sure children Goroutine has chance to finish.\nChannel Channel holds the following properties:\n Goroutine-safe (Multiple Goroutines can access to shared channel without race condition) FIFO queue semantics  Channel always return 2 value: 1 is object returned, 1 is status (true means valid object, false means no more values will be sent in this channel)\nintStream := make(chan int) close(intStream) integer, ok :=  intStream fmt.Printf(\"(%v): %v\", ok, integer) // (false): 0 Channel direction var dataStream chan interface{} //read from only channel var dataStream chan interface{} // write to only channel var dataStream chan interface{} // 2 ways Channel capacity Default capacity of a channel is 0 (unbuffered channel). Reading from empty or writing to full channel is blocking.\nc := make(chan int,10) //buffered size of 10 c := make(chan int) //unbuffered channel  if a buffered channel is empty and has a receiver, the buffer will be bypassed and the value will be passed directly from the sender to the receiver.\n Channel behavior against Goroutine When a Goroutine read from or write to a channel, various of behaviours might happen depending on channel state.\nintStream := make(chan int) // 0 capacity channel  go func() { defer close(intStream) for i:=1; i5; i++{ intStream  i } }() //range from a channel for integer := range intStream { // always blocked until the channel is closed \tfmt.Printf(\"%v \", integer) } Below table summarizes all the behaviour:\n   Operations Channel state Result     Read nil Block    Open \u0026 not empty Value    Open \u0026 empyt Block    Closed [default value], false    Write only Compile error   Write nil Block    Open \u0026 full Block    Open \u0026 not full Write value    Closed panic    Receive only Compile error   close nil panic    Open \u0026 not empty Closes channel. Subsequent reads succeed value until channel is empty, then it reads deafult value.    Open \u0026 empty Closes channel. Reads produces default value.    Closed panic    Receive only Compile Error    As the behaviour is clomplex, we should have a way to make a robust and scalable program.\nRobust \u0026 scalable way when working with channel Here is 1 suggestion way:\n At most 1 Goroutine have the ownership of a channel. The channel ownership should be small to be managable. Channel owner have a write-access (chan←); While consumer only have read-only view (←chan).    Channel owners\nResponsibilities:\n Init channel Do write to channel or pass ownership to another goroutine Close channel Encapsulate \u0026 expose channel as a reader channel    Channel consumer\nResponsibilites:\n Handle when channel is closed Handle blocking behaviour when reading from channel    chanOwner := func() chan int { resultStream := make(chan int, 5) //init \tgo func() { defer close(resultStream) // close \tfor i:=0;i5;i++{ resultStream  i // write \t} }() return resultStream // read channel returned } resultStream := chanOwner() for result := range resultStream { fmt.Printf(\"Received: %d\\n\", result) } fmt.Println(\"Done receiving!\") Refereneces:\nConcurrency in Go: Tools and Techniques for Developers - Book by Katherine Cox-Buday\n","wordCount":"647","inLanguage":"en","datePublished":"2022-05-25T07:45:47+07:00","dateModified":"2022-05-25T07:45:47+07:00","author":{"@type":"Person","name":"Viet Le"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vietmle.com/posts/go_conc_intro/"},"publisher":{"@type":"Organization","name":"Viet Le's Tech Blog","logo":{"@type":"ImageObject","url":"https://vietmle.com/images/ava.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://vietmle.com/ accesskey=h title="Home (Alt + H)"><img src=https://vietmle.com/images/ava.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://vietmle.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://vietmle.com/series/ title=Series><span>Series</span></a></li><li><a href=https://vietmle.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://vietmle.com/posts/about_me title="About me"><span>About me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vietmle.com/>Home</a>&nbsp;»&nbsp;<a href=https://vietmle.com/posts/>Posts</a></div><h1 class=post-title>Intro to Concurrency in Golang</h1><div class=post-meta><span title="2022-05-25 07:45:47 +0700 +0700">May 25, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Viet Le</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#fork-join-model aria-label="Fork-join model">Fork-join model</a></li><li><a href=#channel aria-label=Channel>Channel</a><ul><li><a href=#channel-direction aria-label="Channel direction">Channel direction</a></li><li><a href=#channel-capacity aria-label="Channel capacity">Channel capacity</a></li><li><a href=#channel-behavior-against-goroutine aria-label="Channel behavior against Goroutine">Channel behavior against Goroutine</a></li></ul></li><li><a href=#robust--scalable-way-when-working-with-channel aria-label="Robust &amp;amp; scalable way when working with channel">Robust & scalable way when working with channel</a></li></ul></div></details></div><div class=post-content><p>When dealing with conccurency problem, it is harder to reason about when moving down the stack of abstraction (machine, process, thread, hardware components, etc). Most programming languages use thread as its highest level of abstraction. Fortunately, Go build on top of that & introduce <strong>Goroutine</strong>.</p><blockquote><p>“Share memory by communicating, don’t communicate by sharing memory.” - One of Go&rsquo;s mottos</p></blockquote><p>Although Golang provides traditional locking mechanism in <code>sync</code> package, its philosophy prefers “share memory by communicating”. Therefore, Golang introduces <strong>channel</strong> as the medium for <strong>Goroutines</strong> to communicate with each other.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//goroutine
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=c1>// do some work
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//channel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>dataStream</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span></code></pre></div><h2 id=fork-join-model>Fork-join model<a hidden class=anchor aria-hidden=true href=#fork-join-model>#</a></h2><p><img loading=lazy src=/images/Go_con_model.png alt="Fork-join concurrency model that Go follows">
<em>Fork-join concurrency model that Go follows</em></p><p>This concurrency model is used in Golang. At anytime; a child Goroutine can be <em>fork</em> to do concurrent work with its parent & then will <em>join</em> back **at some point.</p><p>Every Go program has <em>a main Goroutine</em>. The main one can be exit earlier than its children; as a result, a join point is needed to make sure children Goroutine has chance to finish.</p><h2 id=channel>Channel<a hidden class=anchor aria-hidden=true href=#channel>#</a></h2><p>Channel holds the following properties:</p><ul><li>Goroutine-safe (Multiple Goroutines can access to shared channel without race condition)</li><li>FIFO queue semantics</li></ul><p>Channel always return 2 value: 1 is object returned, 1 is status (<code>true</code> means valid object, <code>false</code> means no more values will be sent in this channel)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>intStream</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>close</span><span class=p>(</span><span class=nx>intStream</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>integer</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>intStream</span> 
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;(%v): %v&#34;</span><span class=p>,</span> <span class=nx>ok</span><span class=p>,</span> <span class=nx>integer</span><span class=p>)</span> <span class=c1>// (false): 0
</span></span></span></code></pre></div><h3 id=channel-direction>Channel direction<a hidden class=anchor aria-hidden=true href=#channel-direction>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>dataStream</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span> <span class=c1>//read from only channel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>dataStream</span> <span class=kd>chan</span><span class=o>&lt;-</span> <span class=kd>interface</span><span class=p>{}</span> <span class=c1>// write to only channel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>dataStream</span> <span class=kd>chan</span> <span class=kd>interface</span><span class=p>{}</span> <span class=c1>// 2 ways
</span></span></span></code></pre></div><h3 id=channel-capacity>Channel capacity<a hidden class=anchor aria-hidden=true href=#channel-capacity>#</a></h3><p>Default capacity of a channel is 0 (unbuffered channel). Reading from empty or writing to full channel is blocking.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span><span class=mi>10</span><span class=p>)</span> <span class=c1>//buffered size of 10
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>c</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=c1>//unbuffered channel
</span></span></span></code></pre></div><blockquote><p>if a buffered channel is empty and has a receiver, the buffer will be bypassed and the value will <em>be passed directly from the sender to the receiver.</em></p></blockquote><h3 id=channel-behavior-against-goroutine>Channel behavior against Goroutine<a hidden class=anchor aria-hidden=true href=#channel-behavior-against-goroutine>#</a></h3><p>When a Goroutine read from or write to a channel, various of behaviours might happen depending on channel state.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>intStream</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=c1>// 0 capacity channel
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>intStream</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>&lt;=</span><span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=nx>intStream</span> <span class=o>&lt;-</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//range from a channel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>integer</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>intStream</span> <span class=p>{</span> <span class=c1>// always blocked until the channel is closed
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v &#34;</span><span class=p>,</span> <span class=nx>integer</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Below table summarizes all the behaviour:</p><table><thead><tr><th>Operations</th><th>Channel state</th><th>Result</th></tr></thead><tbody><tr><td>Read</td><td>nil</td><td>Block</td></tr><tr><td></td><td>Open & not empty</td><td>Value</td></tr><tr><td></td><td>Open & empyt</td><td>Block</td></tr><tr><td></td><td>Closed</td><td>[default value], <code>false</code></td></tr><tr><td></td><td>Write only</td><td>Compile error</td></tr><tr><td>Write</td><td>nil</td><td>Block</td></tr><tr><td></td><td>Open & full</td><td>Block</td></tr><tr><td></td><td>Open & not full</td><td>Write value</td></tr><tr><td></td><td>Closed</td><td><code>panic</code></td></tr><tr><td></td><td>Receive only</td><td>Compile error</td></tr><tr><td>close</td><td>nil</td><td><code>panic</code></td></tr><tr><td></td><td>Open & not empty</td><td>Closes channel. Subsequent reads succeed value until channel is empty, then it reads deafult value.</td></tr><tr><td></td><td>Open & empty</td><td>Closes channel. Reads produces default value.</td></tr><tr><td></td><td>Closed</td><td><code>panic</code></td></tr><tr><td></td><td>Receive only</td><td>Compile Error</td></tr></tbody></table><p>As the behaviour is clomplex, we should have a way to make a robust and scalable program.</p><h2 id=robust--scalable-way-when-working-with-channel>Robust & scalable way when working with channel<a hidden class=anchor aria-hidden=true href=#robust--scalable-way-when-working-with-channel>#</a></h2><p>Here is 1 suggestion way:</p><ul><li>At most 1 Goroutine have the ownership of a channel. The channel ownership should be small to be managable.</li><li>Channel owner have a write-access (<code>chan←</code>);</li><li>While consumer only have read-only view (<code>←chan</code>).</li></ul><ol><li><p><strong>Channel owners</strong></p><p>Responsibilities:</p><ul><li><strong>Init</strong> channel</li><li>Do <strong>write</strong> to channel or <strong>pass ownership</strong> to another goroutine</li><li><strong>Close</strong> channel</li><li>Encapsulate & expose channel as a reader channel</li></ul></li><li><p><strong>Channel</strong> <strong>consumer</strong></p><p>Responsibilites:</p><ul><li>Handle when channel is closed</li><li>Handle blocking behaviour when reading from channel</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>chanOwner</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>()</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=nx>resultStream</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=c1>//init
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nb>close</span><span class=p>(</span><span class=nx>resultStream</span><span class=p>)</span> <span class=c1>// close
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span><span class=nx>i</span><span class=o>&lt;=</span><span class=mi>5</span><span class=p>;</span><span class=nx>i</span><span class=o>++</span><span class=p>{</span> 
</span></span><span class=line><span class=cl>			<span class=nx>resultStream</span> <span class=o>&lt;-</span> <span class=nx>i</span> <span class=c1>// write
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>resultStream</span> <span class=c1>// read channel returned
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>resultStream</span> <span class=o>:=</span> <span class=nf>chanOwner</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>result</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>resultStream</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Received: %d\n&#34;</span><span class=p>,</span> <span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Done receiving!&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p><strong>Refereneces:</strong></p><p>Concurrency in Go: Tools and Techniques for Developers - Book by Katherine Cox-Buday</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://vietmle.com/tags/golang/>Golang</a></li><li><a href=https://vietmle.com/tags/concurrency/>concurrency</a></li></ul><nav class=paginav><a class=prev href=https://vietmle.com/posts/5_con_patterns_go/><span class=title>« Prev Page</span><br><span>5 concurrency patterns in Golang</span></a>
<a class=next href=https://vietmle.com/posts/min_cors/><span class=title>Next Page »</span><br><span>The minimum every developer must know about CORS</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://vietmle.com/>Viet Le's Tech Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>